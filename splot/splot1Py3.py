import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator
import itertools
from pylab import rcParams
#### Figure reshape Method 1: but the aspect ratio also depends on the data.
#### I don't know if this gonna work for general plot
#rcParams['figure.figsize'] = 12, 8

#plt.style.use('../splot/styles/billinge.mplstyle')
#mpl.style.use('../splot/styles/billinge.mplstyle')
plt.style.use('../splot/styles/mycopy.mplstyle')
c = [color['color'] for color in list(rcParams['axes.prop_cycle'])]

def data(data, samplename='none', scan='scan',
         line=None, color=None, marker=None):
    """Make a data dictionary with keys: data, samplename, scanname,
    and optional keys to specify plotting style: line, color, and marker.

    Parameters:
    -------------
    data:tuple
        (x, y) where x and y each is an array for plotting
    samplename: str
        sample name
    scan: str
        scan name
    line:str, optional
        linestyle for matplotlib plotting.
    color:str, optional
        color for plotting the data.
    marker:str, optional
        markder for plotting the data.

    Returns:
    --------
        A dictionary with keys 'data', 'samplename', 'scanname'. If any of the
        optional keys are specified, the dicionary will also include it.
        Otherwise the data dictionary only has the three keys.
    """
    d = {}
    d['samplename'] = samplename
    d['scanname'] = samplename + scan
    d['data'] = data
    if line:
        d['line'] = line
    if color:
        d['color'] = color
    if marker:
        d['marker'] = marker
    return d

class Splot:
    """Contains functions for quick plotting as Billinge Group Standard figures.

    User must generate a data dictionary by the data function in this module.
    This class only handles plotting.

    Attributes:
    -------------
    row: int
        the number of rows in the plotting panel. Default value is 1 row.
    col: int
        the number of columns in the plotting panel. Default value is 1 column.
    fig: object
        the figure object in matplotlib.
    ax: ndarray
        an 2D array of same number of rows and cols as in the plotting panel.
        Each entry contains axes objects in matplotlib to plot each subplot.
    axbig: oject
        an axes object in matplotlib to make tile and labels for overall plot.
    legends: tuple
        in the form of (lines, labels)
        where the lines is an array of line objects
        and the labels is an array of the scan names of the data and used
        as the legends in the figure.
    subd: ndarry
        an 2D array of same number of rows and cols as in the plotting panel.
        Each entry is a tuple (x, y) where x is a list of x arrays plotted
        in the subplot and y is a list of the correponding y arrays.
    """

    def __init__(self, r=1, c=1):
        """Create a new plotting panel as r rows by c colums."""
        self.row, self.col = r, c
        self.fig, self.ax = plt.subplots(self.row,  self.col,
                                         sharex='col', sharey='row',)
                                         #figsize = (8, 6))
#### Figure reshape Method 2: Similar to Method 1,
#### but can be specific for each plot.
#### Cons: Use has to come to here to change the code....
        self.fig.tight_layout()
        self.axbig = self.fig.add_subplot(111, frameon = False)
        self.axbig.tick_params(labelcolor ='none',
                               top ='off', bottom ='off',
                               left ='off', right ='off')
        self.axbig.grid(False)
        self.legends = ([], [])
        self.subd = np.empty( (self.row,  self.col), object)
        for i, j in itertools.product(range(r), range(c)):
            self.subd[i,j] = ([], [])
        self.fig.subplots_adjust(wspace = 0.0, hspace = 0.0)
        if r == 1 and c == 1:
            self.ax = np.array([self.ax]).reshape(-1, 1)
        elif r == 1 or c == 1:
            self.ax = self.ax.reshape((r, c))
        return

    def plotData(self, d, r=0, c=0, scal=1, offsetx=0, offsety=0,
                 diff=False, legend=None):
        """Plot data.

        Parameters:
        -------------
        d: dictionary
           a data dictionary generated by the data() function.
        r and c: int
           Optional when figure has a sinlge plot.
           r and c refers to the subpolot postition of
           where the data is being plotted.
           Default position is subplot(0,0) if the figure has multi subplots.
        scal:float, optional
            scaling factor for the y range of data in plotting.
            Default value is 1 as no scaling is applied.
        offsetx: float, optional
            the amount of offset on x axis when plot data.
        offsety: float, optional
            the amount of offset on y axis when plot data.
        diff: bool, optional
            When set to be True, the subplot will include the diffrence curve
            of the first two curves plotted in the same subplot.
        legend:str, optional
            To create the legend for the plot.
            Value choices are "In" and "Out".
            When set to "In", each subplot will have its own legend.
            When set to "Out", there is only one overall lengend
            outside of the plot for all lines plotted in the figure.

        Return:
        --------
        A updated figure.
        """
        line, = self.ax[r, c].plot( d['data'][0] + offsetx, \
                                    d['data'][1]*scal + offsety, \
                                    label = d['scanname'])
        if 'line' in d:
            plt.setp(line, linestyle = d['line'])
        if 'color' in d:
            plt.setp(line, color = d['color'])
        if 'marker' in d:
            plt.setp(line, marker = d['marker'])
        self.addData(d, r, c)
        if d['scanname'] not in self.legends[1]:
            self.legends[0].append(line)
            self.legends[1].append(d['scanname'])
        if diff == True:
            self.diffC(r, c)
        self.ticks()
        self.label()
        self.title()
        self.legend(disp = legend)
        return

    def addData(self, d, r, c):
        """helper method for plotData() to update subd.

        Parameters:
        -------------
        d: dictionary
         a data dictionary generated by the data() function.
        r and c: int
         the row and col number of the subplot where the data is being plotted.

        Return:
        --------
        subd: ndarray
            updated subd.
        """
        self.subd[r, c][0].append( d['data'][0] )
        self.subd[r, c][1].append( d['data'][1] )
        return self.subd

    def diffC(self, r=0, c=0, scal=1, offset=None):
        """Method to plot the difference curve at subplot(r, c),
        also a helper function for plotData()

        Parameters:
        -------------
        r and c: int
           Optional when figure has a sinlge plot.
           r and c refers to the subpolot postition of
           where the difference curve is being plotted.
           Default position is subplot(0,0) if the figure has multi subplots.
        scal:float, optional
            Scaling factor for the y range of difference curve in plotting.
            Default value is 1 as no scaling is applied.
        offset: float, optional
            the amount of offset on y axis when plot the diff Curve.
            Default value is None, where the peak of the diff curve is
            seperated by %10 of the data range below the lower curve.
        """
        if len (self.subd[r, c][1]) != 2:
            raise ValueError( "subplot(%d, %d) must have EXACTLY 2 curves \
                     to calcualte the diff Curve, now you have %d curves here."
                     %(r, c, len (self.subd[r, c][1]) ) )
         ## Need to ask.
        diffy = self.subd[r,c][1][0] - self.subd[r, c][1][1]
        if offset == None:
            h = max (self.subd[r, c][1][0].max(), self.subd[r, c][1][1].max())
            l = min (self.subd[r, c][1][0].min(), self.subd[r, c][1][1].min() )
            amp = h-l
            offset = l - diffy.max() - amp*0.1
        line, = self.ax[r, c].plot( self.subd[r,c][0][0], diffy*scal + offset,\
                                     label = 'diff')
        plt.setp(line, color = 'g')
        plt.setp(line, linestyle = '-')
        if "diff" not in self.legends[1]:
            self.legends[0].append(line)
            self.legends[1].append('diff')
        return

    def ticks(self):
        """helper method for plotData() to remove the overlapping ticks."""
#        nbins = len( self.ax[0, 0].get_xticklabels() )
        nbins = 6                   #??? fix a grid density
        for i in range(self.row):
            self.ax[i, 0].yaxis.set_major_locator(\
                        MaxNLocator(nbins, prune='both'))
            self.ax[i, 0].minorticks_on()
        for i in range(self.col):
            self.ax[-1, i].xaxis.set_major_locator(
                            MaxNLocator(nbins, prune='both'))
            self.ax[-1, i].minorticks_on()
        return

    def label(self, x='r', xunit='AA', y='G', yunit='AA^{-2}', math=True):
        """Method generate labels for axis in the overall plot.

        Parameters:
        -------------
        x: str, optional
          the label for x axis. Default value is 'r' as in a G(r) plot
        xunit: str, optional
          unit for the x axis.
          Default value is 'AA', a Latex command for Angstrom.
          To see this Math symbol, the 'math' parameter has to be 'True'.
        y: str, optional
          the label for y axis. Default value is 'G' as in a G(r) plot
        yunit: str, optional
          unit for the y axis.
          Default value is 'AA^{-2}' for G(r)
          a Latex command for the inverse square of Angstrom.
          To see the Math symbol, the 'math' parameter has to be 'True'.
        math: bool, optional
          Ture: default value. Turn on the math expression for the labels.
          False: write the labels as normal text.
        """
        if math:
            xl = r'$\mathrm{%s}\  \mathrm{( \%s )}$' %(x, xunit)
            yl = r'$\mathrm{%s}\  \mathrm{( \%s )}$' %(y, yunit)
        else:
            xl = '%s (%s)' %(x, xunit)
            yl = '%s (%s)' %(y, yunit)
        self.axbig.set_xlabel(xl)
        self.axbig.set_ylabel(yl)
        return

    def title(self, t='', math=False):
        """Method generate labels for axis.

        Parameters:
        -------------
        t: str, optional
         the tile of the overal plot.
         Default to be empty.
        math: bool, optional
          Ture: Turn on the math expression for the labels.
          False: default. Write the labels as normal text.
        """
        if math:
            t = r'$\mathrm{%s} $' %t
        return self.axbig.set_title(t)

    def legend(self, disp=None):
        """Method to create legend for the figure.

        Parameters:
        -------------
        disp: str, optional
            Chose if the legend is outside or inside of the plotting area.
            "None": default value. No legend on the plot.
            "out": an overall outside legend for all lines in the figure
            "in": each subplot has its own legend.
        """
        if disp:
            if disp == 'out':
                self.legendOut()
            if disp == 'in':
                self.legendIn()
        return

    def legendOut(self):
        """helper method for the legend(), creating an overall legend
        for all lines. The legend is outside of the plotting box."""
        return plt.legend(self.legends[0], self.legends[1], loc='center left',
                   bbox_to_anchor = (1, 0.6), borderaxespad=0, \
                   labelspacing= 1., prop={'size':8}, handlelength = 3)

    def legendIn(self):
        """helper method for the legend(),
        creating legends inside of each subplot."""
        for i, j in itertools.product(range(self.row), range(self.col)):
            self.ax[i,j].legend(loc = 'upper right', \
                                labelspacing= 1.,
                                prop={'size':8}, handlelength = 3)
        return

    def save(self, name="myplot", form="pdf"):
        """Save the plot to the current working diretory.

        Parameters:
        -------------
        name: str
            the name of plot being saved.
        form:str, optional
            the form of figure file. Example, png, eps, pdf.
        """
        return self.fig.savefig( '%s.%s' %(name, form) )

    def show(self):
        """Show figure in a GUI window."""
        return self.fig.show()

    #### Figure reshape Method 3: Similar to Method 1 or 2.
    ####This changes the overal figure shape. Recommend to use this one :)
    def figureSize(self, width, height):
        """Change the current figure shape or size"""
        self.fig.set_figwidth(width)
        self.fig.set_figheight(height)
        return

    #### Figure reshape Method 4: rescale subplot axes ratio.
    #### Doesn't work well, not recommend....
    def aspect(self, ratio):
        """ a method to change the aspect ratio in by a ratio factor.

        Note: this doesn't work well, because axis range in each subplot is
        rescaled by the same amount. When the ratio is not proper,
        part of the curve will be cut off in some subplot.

        Parameters:
        -------------
        ratio: float
            a factor to be multipled by the current aspect for all subplots.
            Example:
            ratio = 1 to maintain the auto scaled aspect ratio.
            ratio = 2 to half the auto aspect ratio (double x ranges with
            centering the data).
            ratio = 1/2 to double the auto aspect ratio (double y ranges with
            centering the data).

        Returns:
        --------
        An updated figure.
        """
        for i, j in itertools.product(range(self.row), range(self.col)):
            ll, ur = self.ax[i,j].get_position() * self.fig.get_size_inches()
            width, height = ur - ll
            axesratio = height / width
            aspect = axesratio / self.ax[i,j].get_data_ratio()
#            self.ax[i, j].set_aspect (ratio * aspect, adjustable='box-forced')
            # Cons: may sepearte the subplots
            self.ax[i, j].set_aspect (ratio * aspect)
            # Cons: may cut off part of the data
        return

    def setXLim(self, col, low, high):
        """ a method to manually set the x range in plot.

        Parameters:
        -------------
        col: int
            the column at which the shared x-axis limit should be set.
        low: float
            the lower bound of the x-axis being set.
        high: float
            the higher bound of the x-axis being set.
        """
        return self.ax[0,col].set_xlim([low, high])

    def setYLim(self, row, low, high):
        """ a method to manually set the shared y range in the plot.

        Parameters:
        -------------
        row: int
            the row at which the shared y-axis limit should be set.
        low: float
            the lower bound of the y-axis being set.
        high: float
            the higher bound of the y-axis being set.
        """
        return self.ax[row,0].set_ylim([low, high])